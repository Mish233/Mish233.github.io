<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8"> 
<meta name="keywards" content="Mish233,Blog">
<meta name="author" content="Mish233">

<title>
    Mish233&#39;s Blog
</title>

<link rel="icon" type="image/jpg" href="">

<!--  -->

<link rel="stylesheet" href="/css/Style.css">


<link rel="stylesheet" href="/css/Index.css">


<link rel="stylesheet" href="/css/Page.css">


<link rel="stylesheet" href="/css/Post.css">


<script src="/js/JSLoader.js"></script>


<script src="/js/Current_Time.js"></script>


<script src="/js/HoverLink.js"></script>

<!--  -->

<meta name="generator" content="Hexo 7.3.0"></head>

<body class="Body_container" onload="ScriptLoader()">

    <!--
    对hexo内部函数用注释线划分了 
    -->

    <!-- 头部 -->
    <div class="Top_container">

        <!-- 头部_导航栏 -->
<div class="Top_Navigator">
    <!-- 无序列表，列出各页面 -->

    <ul>
        
        <!-- Home -->
        <li><a href="/">Home</a></li>

        <!-- 子页面 -->
        <!--  -->
        
            <li><a href="/Link/Link.html">Link</a></li>
        
            <li><a href="/About/About.html">About</a></li>
        
        <!--  -->
        
    </ul>
</div>

<!-- 头部_背景 -->
<div class="Top_Background">
    <!-- 背景图片 -->

    <img src="../../../../img/Top_background.jpg">

</div>

<!-- 头部_标题 -->
<div class="Top_Title">
    <!-- 头部标题 -->
    <p>Mish233&#39;s Blog</p>
</div>



    </div>

    <!-- 中部 -->
    <div class="Mid_container">

        <!-- 左侧栏_个人区 -->
<div class="Body_PortraitFramework">

    <!-- 头像 -->
    <div class="Body_Portrait_Img">

    <img src="../../../../img/portrait.jpg">

</div>

    <!-- 图像式个人联系栏 -->
    <div class="Body_Portrait_ImgNavigator">

<!--  -->
    
        
            <a target="_blank" rel="noopener" href="https://github.com/Mish233">
            <img src="../../../../img/github.png">
            </a>
        
            <a href="mailto:ffmg2165348339@gmail.com">
            <img src="../../../../img/gmail.png">
            </a>
        
    
<!--  -->

</div>
    
    <!-- 标签导航栏 -->
    <div class="Body_Portrait_TagsNavigator">

    <!--  -->
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/Git/">
    <a href="/tags/Git/">Git</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
    <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E4%B8%AA%E4%BA%BA%E8%A8%80%E8%AE%BA/">
    <a href="/tags/%E4%B8%AA%E4%BA%BA%E8%A8%80%E8%AE%BA/">个人言论</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </div>
    
    <!--  -->

</div>


</div>

<!-- 右侧栏_文章区 -->
<div class="post">
    <!-- 我定义其为文章内容区 -->

    <!-- 文章_标题 -->
    <div class="post_title">

        <h1>C++萌新手册</h1>

    </div>

    <!-- 文章_属性（副标题）（补充内容） -->
    <div class="post_subtitle">

        <a>2024年11月20日</a>

    </div>
    
    <!-- 文章_正文 -->
    <div class="post_content">
        
    <a><h1 id="C-萌新手册"><a href="#C-萌新手册" class="headerlink" title="C++萌新手册"></a>C++萌新手册</h1><h2 id="N1-开始"><a href="#N1-开始" class="headerlink" title="N1-开始"></a>N1-开始</h2><p>用一个C++的函数作为开头吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cout&lt;&lt;&quot;hello_world&quot;&lt;&lt;endl;</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数，我们引入了头文件<code>&lt;iostream&gt;</code>库。头文件是C++里类似于python里的库的存在，它提供了多种多样的功能函数（类），可被多个程序（内的函数）使用的一种机制。通过<code>#include</code>来引进头文件。</p>
<p>类似于数学$F(X)&#x3D;Y$函数，C++里的函数的实质是输入-输出的过程。<br>函数是一个具有名字的计算单元，我们定义函数由——函数名，函数体，输出格式组成。</p>
<p>输出格式前置于函数名，它是这个函数输出结果的数据类型。<br>函数名是函数为人所知的名字。也是未来调用函数（功能）时唯一辨识你的函数的依据（不然？李逵，李逵，李逵函数？你哪知道哪个李逵是你真正要的函数）<br>函数体是一个语句块，是你的参数（没事，很快就讲到）执行语句，进行计算的场所。函数体定义了你的函数所执行的动作。我们使用大括号{}将函数体部分包括起来</p>
<p>如你所见，普通括号里没有东西，那J8的又是什么呢？X又是什么呢？作为一个一元函数，X作为一个未知变量，是一元函数里唯一的参数，以影响Y这个输出结果<br>普通括号里正对应着数学函数里的“参数”，我们又称其为形参（形式参数）。这是函数里我们所假设出来的“所需要的”形式变量<br>我们之后有“实参”的概念，类比“实例”，实参我们可以当作成“形式参数的实例化”。好比是，我们的形式参数被赋予了实际数值</p>
<p>现在，看回我们的函数 main（必须有），有了参数，有了动作，输出结果，一气呵成。我们成功地编写出了一个简单的C++程序！</p>
<h2 id="N2-变量以及基本类型"><a href="#N2-变量以及基本类型" class="headerlink" title="N2-变量以及基本类型"></a>N2-变量以及基本类型</h2><p>类型是C++编程的基础</p>
<p>类型规定了其对象的存储要求和所能执行的操作。C++提供了一套非常基础的内置类型，比如int，char等，这些类型与实现它们的机器硬件密切相关。</p>
<p>变量必须被声明为一个类型，类型作为变量的容器（封装）。</p>
<p>基本类型是类型说明的“符号”，我们可以使用const（常量）进行修饰。const说明“符号”用于说明const所指定（使用）的基本类型对象 永远不会改变自身被赋予的值，必须通过初始化才能进行更改</p>
<p>复合类型是一种类型，基于基本类型而存在。比如指针和引用。指针是一种（本身）对象，存放着指向对象的地址，或者某个对象存储区域之后的下一地址，或者0（空指向）；而引用是某个对象的别名，它不是一个”对象“，正如字意”引用“（引进-运用）。</p>
<p>初始化是针对类型-变量的。当类型对象未被显式地赋予初始值时，会为这个类型对象自动赋值”初始化“。变量一般都应该被初始化（试图访问未初始化变量的值将引发未定义行为）</p>
<p>值得一提的功能<br>auto类型：一个类型说明”符号“，通过变量的初始值来推断变量的类型（自动化赋类）<br>constexpr函数：代表一条常量表达式<br>decltype：类型说明”符号“，从变量或者表达式推断得出类型<br>typedef：类型别名，声明某个类型的其他名字<br>void类型：有特殊用处的类型，既无操作又无值。不能定义void的变量</p>
<p>补充：（不知道放哪）<br>预处理器：在C++编译过程中执行的一段程序<br>在C++里，代码经过预处理（读取头文件）-编译（编程语言翻译成低级机器语言）-汇编（汇编成机器语言）-链接（合并文件）</p>
<h2 id="N3-字符串，向量和数组"><a href="#N3-字符串，向量和数组" class="headerlink" title="N3-字符串，向量和数组"></a>N3-字符串，向量和数组</h2><p>string（字符串）和vector数组是两种最重要的标准库类型。string对象是一个可变长的字符序列（实质是字符的数组，就类似“ 我 是 老 色 批 给 我 色 图 ”这样），vector对象是一组同类型对象的容器</p>
<p>迭代器允许对容器中对象进行间接访问，利用迭代器<code>for( ; ;)</code>对数组进行遍寻吧</p>
<p>一般优先选择标准库内提供的类型（先进，高效），之后再考虑C++内置的那些破东西</p>
<p>一般来说，我们要么看到<code>using namespace std;</code>，亦或<code>std::int i = 20+1;</code>。我们C++特别引入了“命名空间”一说，命名空间类比于“文件里的程序名”吧，不同的命名空间可以使用同一名字的函数，很多时候我们的程序员有这样的强迫症吧，就是想取一样的名字的函数。命名空间就是用来避免不经意之间的名字冲突，专门区分不同库而函数相同名字（有些头文件编者不会知道其他头文件编者所编写的头文件函数叫啥的）</p>
<h2 id="N4-表达式"><a href="#N4-表达式" class="headerlink" title="N4-表达式"></a>N4-表达式</h2><p>C++语言提供了一套丰富的运算符，并定义了这些运算符作用于内置类型的运算对象时所使用的操作。C++支持运算符重载的机制，允许我们定义运算符作用于类类型时的含义。</p>
<p>拥有超过一个运算符的表达式，理解优先级，结合律，求值顺序。</p>
<p>大多数运算符并不明确运算对象的求值顺序：编译器有权自由选择先对左侧运算对象求值还是先对右侧运算对象求值。一般来说，运算对象的求值顺序对表达式的最终结果没有影响</p>
<p>运算对象经常从原始类型自动转换成某种关联的类型。根据需要，我们可以显式地进行强制类型转换</p>
<p>表达式是C++程序中最低级别的计算。表达式将运算符运算符作用于一个或多个运算对象，每个表达式都有对应的求值结果。表达式本身也可以作为运算对象</p>
<p>以等号为中心，我们将“表达式”划分为左值和右值（准确来说，左值和右值都是属于表达式，这里的表达式只是称谓方便）。左值是指那些求值结果为对象或者函数的表达式。表示对象的非常量左值可以作为赋值作用符（等号）的左侧运算对象；而右值是指一种表达式，结果是值，而非值的所在位置（非实际占位的）</p>
<p>值得一提的功能：<br>const_cast：一种涉及const的强制类型转换，将底层const对象转换成对应非常量对象<br>dynamic_cast：动态转换<br>static_cast：显式地执行某种定义明确的类型转换，替代编译器的隐式类型转换<br>reinterpret_cast：把运算对象内容解释成为另外一种类型。强制转换非常危险！</p>
<h2 id="N5-语句"><a href="#N5-语句" class="headerlink" title="N5-语句"></a>N5-语句</h2><p>C++仅提供了有限的语句类型，它们的大多数会影响程序的控制流程</p>
<p>以下是语句：<br>while，for，do while语句执行迭代循环操作<br>if，switch提供条件分支结构<br>continue语句，终止循环并进行下一次迭代循环<br>break语句，退出循环和switch<br>goto语句，将指令执行（位置）转移到一个标签标记点位<br>try和catch，将一段可能抛出异常语句序列以大括号{}括在try语句块里。catch子句负责处理代码抛出的异常<br>throw语句，在代码块内，将指令执行（位置）转移到相关的catch子句<br>return语句，终止函数的执行。</p>
<h2 id="N6-函数"><a href="#N6-函数" class="headerlink" title="N6-函数"></a>N6-函数</h2><p>函数是命名的计算单元，它对程序的结构化至关重要。每个函数都包含着返回类型，名字，形参列表（形式参数，参考N1），以及函数体。函数被调用时，函数执行函数块的内容（动作）。传递给函数的实参类型必须对应形参的类型！</p>
<p>在C++语言中，函数可以被重载：同一个名字可用于定义多个函数（都是形式参数了，函数是形式性的。也就是说，我们构建的函数是形式化的，通过狠狠地注入实参，让形式函数实例化），只要形参数量或者形参类型不同就行。从一组重载函数中选取最佳函数的过程被称为函数匹配。</p>
<p>参数是函数内固有的变量值（符号），我们能看到的“参数”有形参和实参。形参是在函数形参列表中声明的局部变量，而实参是函数调用时提供的实际值，用于初始化（实例化）函数的形参（狠狠注入实际参数）。参数传递——实参的实例传递给形式化的形参，通俗来讲，狠狠注入，简洁明了</p>
<p>在函数内，我们使用小括号（）（英文格式，我这里用中文是为了可读性！）注入形参。小括号（）是一个调用运算符，是一个（形式）函数内的，伴随（形式）函数而注入形式参数，并一同创建。</p>
<p>对于重载函数，诚然这个函数可以在名字上与其他的同名函数重名，但是多个重载函数必须在形参数量（我是李逵，我有两只手；我是李逵，我有三只手。当然能分出谁是谁）或形参类型（我是李逵，我有三颗眼睛；我是李逵，我有两颗眼睛和一个鼻子。这样也是能分出来谁是谁的）（只要形式函数不会完全匹配（相似度一摸一样），我们默认这个函数不一样）有所区别。</p>
<p>每个对象都有其生命周期——从生成，到死亡（销毁）。块内定义的非静态对象的生命周期从它的定义（出生）开始，到块内末尾为止（死亡）。对于全局对象，程序控制流经过局部静态对象的定义时创建该局部静态对象；当main函数结束时销毁全局对象和局部静态对象（因为你的程序也相应结束了）</p>
<h2 id="N7-类"><a href="#N7-类" class="headerlink" title="N7-类"></a>N7-类</h2><p>类是C++语言中最基本的特性。类允许我们为自己的应用定义新类型（面向 对象（OO），向一个全新的对象展开怀抱，随时（根据需要）欢迎到来（自定义创建），让类型大家庭增添新的一员（当然不是严格的定义，个人理解）），从而使程序更加简洁且易于修改。</p>
<p>类有两项能力：数据抽象和封装。<br>数据抽象，即定义数据成员和类函数成员的能力<br>封装，即保护类的对象不被随意访问的能力（你不能随便拿去狗的内脏，最起码得切开）</p>
<p>类可以定义一种特殊的成员函数：构造函数（后文会提到一个“析构函数”，务必留意），作用是控制初始化对象的方式。构造函数可以重载，使用构造函数初始值列表来初始化所有数据成员</p>
<p>类还可以定义可变或静态成员</p>
<p>在类里面，我们通过访问说明符对类里面的成员进行访问的限制（设置权限）。包括关键字public（公共）和private（私有）。有效范围从它们自身开始，到下一个说明符为止（我们也可以类比一下，不使用这些访问说明符的话，不妨假设为类里面的全局空间（class类默认情况下成员是私有的，而struct类默认情况下成员是公有的））</p>
<p>类是C++提供的自定义数据类型的机制，类可以包括数据，函数，类型成员。一个类定义一种新的类型和一个新的作用域</p>
<p>构造函数是一个用于初始化对象的一种特殊的成员函数，构造函数应该给每个数据成员都赋予一个合适的初始值。在构造函数体执行之前首先用初始值列表中的值初始化数据成员，未经初始值列表初始值化的成员将被默认初始化。没有提供任何实参时，我们会调用默认构造函数</p>
<p>数据抽象和封装是编程语言（乃至计算机学科）里非常重要的思想。<br>数据抽象着重关注类型接口的一种编程技术，它令程序员可以忽视类型（内部的）实现细节，关注类型执行的操作即可（大局观化，忽视微观操作）。数据对象是面向对象编程和泛式编程的基础。<br>封装将类的实现与接口分离，隐藏了类的实现细节。通过将实现部分设为私有完成封装任务</p>
<p>接口一般是类型提供的（公有）操作。接口不包括数据成员。</p>
<p>友元是一个类向外部提供其非公有成员访问权限的一种机制。友元的访问权限和成员函数一样。可以是类，或者函数</p>
<h2 id="N8-C-标准库"><a href="#N8-C-标准库" class="headerlink" title="N8-C++标准库"></a>N8-C++标准库</h2><p>剩下的事情以后再来探索吧？不是咕杀，是咕咕咕</p>
<h3 id="N8-1-IO库"><a href="#N8-1-IO库" class="headerlink" title="N8.1-IO库"></a>N8.1-IO库</h3><p>C++使用标准库类来处理面向流的输入和输出：<br>iostream（IO流）处理控制台IO<br>fstream（f（s）stream，文件控制流）处理命名文件IO<br>stringstream（字符串流）完成内存string的IO</p>
<p>fstream和stringstream都是继承自iostream。</p>
<p>每个IO对象都维护一组条件状态，用来指出此对象上是否可以进行IO操作。遇到错误则对象状态变为失效，后续所有输入操作都不能执行。标准库提供了一组函数用来设置和检测这些状态</p>
<h3 id="N8-2-顺序容器"><a href="#N8-2-顺序容器" class="headerlink" title="N8.2-顺序容器"></a>N8.2-顺序容器</h3><p>标准库容器是模板类型，用来保存给定类型的对象。在一个顺序容器中，元素是按顺序存放的，通过位置来访问。顺序容器有公共的标准接口：两个顺序容器都提供一个特定的操作，那么这个操作在两个容器具有相同的接口和含义</p>
<p>所有容器都提供了高效的动态内存管理（老古董C语言的array除外）。容器自动管理元素的排序存储位置，vector和string都提供了更细致的内存管理，依赖于它们的成员函数reserve和capacity成员函数来实现的</p>
<p>很大程度上，容器只定义了极少的操作（不然…？你要不别叫容器了，有什么名字就该做什么事）。每个容器都定义了构造函数，添加和删除元素的操作，确定容器的大小的操作以及返回特定元素的迭代器操作。</p>
<p>使用添加和删除元素的容器操作时小心，这些操作使你的指向容器元素的迭代器，指针，引用失效。很多会使迭代器失效的操作，如insert和erase，都会返回一个新的迭代器，来帮助程序员维护容器中的位置</p>
<h3 id="N8-3-泛型函数"><a href="#N8-3-泛型函数" class="headerlink" title="N8.3-泛型函数"></a>N8.3-泛型函数</h3><p>标准库大概定义了大约100个类型无关的对序列进行操作的算法。算法通过在迭代器上进行操作来实现类型无关功能。多数函数接受的前两个参数是一对迭代器，表示一个元素范围。额外的迭代器参数可能包括一个表示目的位置的输出迭代器，或是表示第二个输入范围的另一个或另一对迭代器</p>
<p>根据支持的操作不同，迭代器可被分为5类：输入，输出，前向，双向，随机访问迭代器</p>
<p>传递给算法的迭代器参数也按照所要求操作进行分类。算法从不改变他们所操作的序列的大小。算法不能直接向序列添加元素，但插入迭代器可以做到</p>
<p>链表容器对一些通用算法定义了自己特有版本（专门用来修改给定链表）</p>
<p>lambda表达式：可调用的代码单元（内嵌函数，终于不用天天跑出去写class还是啥函数了）。类似于未命名的内联函数。lambda以一个捕获列表中括号[]开始（捕获函数内变量），之后是lambda的参数列表，一个返回类型和函数体。lambda函数忽略返回类型，自己自动判定；存在单一return，返回自动判定出来的类型；否则void</p>
<h3 id="N8-4-关联容器"><a href="#N8-4-关联容器" class="headerlink" title="N8.4-关联容器"></a>N8.4-关联容器</h3><p>关联容器支持通过关键字高效查找和提取元素</p>
<p>标准库定义了8个关联容器，每个容器：<br>是一个map或者set，map保存关键字-值对（数对），set只保存关键字<br>要求关键字唯一或不要求<br>保持关键字有序或不保证有序</p>
<p>允许重复关键字的容器名字都包含multi；使用哈希技术容器都已unordered开头。</p>
<p>关联容器定义了一些新操作，并对一些和顺序容器和关联容器都支持的操作重新定义了含义或返回类型</p>
<p>有序容器的迭代器通过关键字有序访问容器中的元素。具有相同关键字的元素相邻存储的（buckle）</p>
<p>哈希函数：将给定类型的值映射到整型值的函数。相等的值必须映射到相同的整数；不相等值尽可能映射到不同整数</p>
<h3 id="N8-5-动态内存"><a href="#N8-5-动态内存" class="headerlink" title="N8.5-动态内存"></a>N8.5-动态内存</h3><p>C++中，内存是通过new表达式分配，通过delete表达式释放。标准库定义了一个allocator类来分配动态内存块</p>
<p>分配动态内存的程序应负责释放它所分配的内存。内存的正确释放是非常容易出错的地方（内存又泄漏了）：要么内存永远不会被释放，要么在有指针引用时它就被释放了。</p>
<p>新的标准库定义了智能指针类型——shared_ptr，unique_ptr和weak_ptr，可令动态内存管理更为安全（没有用户使用内存则智能指针自动释放占用内存（程序所占用的））。现代C++程序尽可能使用智能指针</p>
<p>空悬指针，指向一个曾经保存过对象，但现在这个对象内存已经释放（对象消失）。尽量别留，会有非常多的错误等着你排雷（且作为对象自己也占用内存）</p>
<p>析构函数：特殊的成员函数，负责对象离开作用域或被释放时，进行“清理工作”</p>
<p>动态分配——在自由空间分配对象。自由空间分配的对象直到被显式释放（没错，问题的来源，要么程序关闭，要么内存泄漏（内存的一种“抽象状态”，某些程序一直在自动释放对象，自动占用自由空间内存，形成了内存泄漏（减少）的假象））或程序结束才会销毁。</p>
<p>自由空间：程序可用的内存池，保存动态分配的对象</p>
<p>智能指针：<br>shared_ptr：提供所有权共享的智能指针：针对共享对象来说，最后一个指向它的shared_ptr被销毁时会被释放<br>unique_ptr：提供独享所有权的智能指针：unique_ptr被销毁时，指向对象释放。不能直接拷贝或赋值<br>weak_ptr：指向由shared_ptr管理的对象。在确定是否应该释放对象时，shared_ptr并不把weak_ptr统计在内</p>
<h2 id="N9-类设计者的工具"><a href="#N9-类设计者的工具" class="headerlink" title="N9-类设计者的工具"></a>N9-类设计者的工具</h2><h3 id="N9-1-拷贝控制"><a href="#N9-1-拷贝控制" class="headerlink" title="N9.1-拷贝控制"></a>N9.1-拷贝控制</h3><p>每个类都会控制该类型对象拷贝，移动，赋值以及销毁时会发生什么。</p>
<p>特殊的成员函数——拷贝构造函数，移动构造函数，拷贝赋值运算符和析构函数（销毁）定义了这些操作。</p>
<p>移动构造函数和移动赋值运算符接受一个右值引用；而拷贝版本则接受一个普通左值引用</p>
<p>如果一个类未声明这些操作，编译器会自动为其生成</p>
<p>分配了内存或其他资源的类几乎总是需要定义拷贝控制成员来管理分配的资源。如果一个类需要析构函数，则它几乎肯定也需要定义移动和拷贝构造函数及移动和拷贝赋值运算符</p>
<p>析构函数是一个特殊的成员函数，当对象离开作用域或被释放时进行清理工作。编译器会自动销毁每个数据成员。类的类型的成员通过调用其析构函数来销毁。内置类型或复合类型的成员的销毁不需要做任何工作，析构函数不会释放指针成员指向的对象</p>
<p>拷贝控制以及相关特殊成员函数，包括控制拷贝，移动，赋值，销毁类的类型对象会发生什么，如果类未定义这些操作，编译器为我们合成一个</p>
<p>各种拷贝类型特殊成员函数接受一个同类型对象的“复制”对象&#x2F;运算符版本，一般是个普通左值引用，将左值的对象“复制”成为右值。</p>
<p>而移动类型特殊成员函数接受一个同类型对象的对象&#x2F;运算符版本，将右值引用对象迁移到左值对象，实现从右边移动到左边的行为。</p>
<h3 id="N9-2-操作重载与类型转换"><a href="#N9-2-操作重载与类型转换" class="headerlink" title="N9.2-操作重载与类型转换"></a>N9.2-操作重载与类型转换</h3><p>一个重载的运算符必须是某个类的成员或者至少拥有一个类类型的运算对象。重载运算符的运算对象数量，结合律，优先级与对应的用于内置类型的运算符完全一致。</p>
<p>如果类重载了函数的调用运算符operator()，则该类的对象被称为“函数对象”。这样的对象常用在标准函数中。lambda表达式是一种简便的定义函数对象类的方式</p>
<p>在类中可以定义转换源或转换目的是该类型本身的类型转换，这样的类将自动执行。</p>
<h3 id="N9-3-面向对象程序设计"><a href="#N9-3-面向对象程序设计" class="headerlink" title="N9.3-面向对象程序设计"></a>N9.3-面向对象程序设计</h3><p>继承使得我们可以编写一些新的类，这些新类共享基类（父类-子类关系）的行为，又能根据需要覆盖或添加行为。动态绑定使得我们可以忽略类型之间的差异，机理是在运行时根据对象的动态类型来选择运行函数的哪个版本。继承和动态绑定的结合使得我们能够编写具有特定类型行为但又独立于类型的程序</p>
<p>动态绑定只作用于虚函数，并且需要通过指针或引用调用。</p>
<p>当执行派生类的构造，拷贝，移动和赋值操作时，首先构造，拷贝，移动和赋值其中的基类部分，然后轮到派生类部分。析构函数则相反（这玩意是收尾的！收尾结束则整个程序都完了）。基类通常都应该定义一个虚析构函数，即使基类根本不需要析构函数也最好这么做。将基类的析构函数定义为虚函数的原因是为了确保当我们删除一个基类指针（能将派生类引用或指针转换为针对基类的指针或引用。没错，派生指针，派生引用，解耦模块化的又一伟大创造），而该指针实际指向一个派生类对象时程序也能正常运行</p>
<p>派生类为它的每个基类提供了一个保护级别。public和private老熟人不提及，protected基类的成员对于派生类的派生类是可访问的，对于派生类的用户不可访问</p>
<p>动态绑定在C++的运行时根据引用或指针绑定对象的实际类型来选择执行虚函数的某一版本</p>
<p>虚函数用于定义类型特定行为的成员函数。通过引用或指针对虚函数的调用直到运行时才被解析，依据是引用或指针所绑定的对象的类型</p>
<p>面向对象编程是利用数据抽象，继承，动态绑定等技术编写程序的方法。<br>继承是——由一个已有的基类，定义一个新子类的编程技术。派生类继承基类成员<br>多态性——用于面向编程的范畴时，含义指程序能够通过引用或指针的动态类型获取特定行为的能力。我愿意将其称为——适应性。这是一个面对多重环境时，对象针对复杂环境而产生的高特化行为的适应行为，多元-状态-性质。<br>覆盖，如果派生类虚函数与基类虚函数重合（有相同的形参列表），派生类虚函数覆盖基类虚函数<br>重构——重新设计程序以便将一些相关的部分搜集到一个单独的抽象中，然后使用新的抽象替换原来的代码。重构类的方法是将数据成员和函数成员移动到继承体系的高级别节点当中，避免代码堆积</p>
<h3 id="N9-4-模板与泛型编程"><a href="#N9-4-模板与泛型编程" class="headerlink" title="N9.4-模板与泛型编程"></a>N9.4-模板与泛型编程</h3><p>模板是C++与众不同的特性，也是标准库的基础。一个模板就是一个编译器用来生成特定类类型或函数的蓝图。生成特定类或函数的过程被称为实例化。只需要编写一次模板，生成无穷无尽的实际函数和类</p>
<p>标准库算法都是函数模板</p>
<p>显式模板实参允许我们固定一个或多个模板参数的类型或值。对于指定了显式模板实参的模板参数，可以应用正常的类型转换</p>
<p>一个模板特例化就是一个用户提供的模板实例，它将一个或多个模板参数绑定到特定类型或值上。当我们不能将模板定义在某些特定类型时，特例化非常有用</p>
<p>最新C++标准的一个主要部分是可变参数模板。一个可变参数模板可以接受数目和类型可变的参数。它允许我们编写像容器的emplace成员和标准库make_shared函数这样的函数，实现将实参传递给对象的构造函数</p>
<p>实例化是编译器处理过程中用实际的模板实参来生成模板的一个特殊实例，其中形参被替换成对应的实参，相应的这个（形式）模板具体化，形成一个实例函数（狠狠注入爱国实参）</p>
<h2 id="N10-高级主题"><a href="#N10-高级主题" class="headerlink" title="N10-高级主题"></a>N10-高级主题</h2><h3 id="N10-1-标准库特殊设施"><a href="#N10-1-标准库特殊设施" class="headerlink" title="N10.1-标准库特殊设施"></a>N10.1-标准库特殊设施</h3><p>我们将介绍一些特殊的I&#x2F;O操作和四个标准库类型：tuple，bitset，正则表达式和随机数</p>
<p>tuple是一个模板，允许我们将多个不同类型的成员捆绑成单一对象。每个tuple包含指定数量的成员，但对一个给定tuple类型，标准库不对定义成员上限作限制</p>
<p>bitset允许我们定义指定大小的二进制位集合。不限制bitset大小但必须和整型类型大小匹配。除了支持普通位运算符，还定义了些命名操作，允许我们操纵bitset中特定位的状态</p>
<p>正则表达式库提供了一组类和函数：<br>regex类 管理 用某种正则表达式语言编写的 正则表达式（说是管理，可理解为保存），保存某个特定匹配的相关信息。<br>regex_search和regex_match，接受一个regex对象和一个字符序列，检查regex中的正则表达式是否匹配给定的字符序列。<br>regex迭代器是迭代器适配器，它们使用regex_search遍历输入序列，返回匹配子序列<br>定义了一个regex_replace函数，允许我们用指定内容替换输入序列中与正则表达式匹配的部分</p>
<p>随机数库由一组随机数引擎和分布类组成。随机数引擎返回一个均匀分布的整型值序列。标准库定义了多个引擎，它们具有不同的性能特点</p>
<p>正则表达式（规范化的表达）是一种描述字符序列的方式</p>
<h3 id="N10-2-用于大型程序的工具"><a href="#N10-2-用于大型程序的工具" class="headerlink" title="N10.2-用于大型程序的工具"></a>N10.2-用于大型程序的工具</h3><p>C++语言可以用于解决各种类型的问题。C++的某些特性特别适合于处理超大规模问题，这些特性包括：异常处理，命名空间，以及多重继承或虚继承</p>
<p>异常处理使得我们可以将程序的错误检测部分与错误处理部分分隔开来。程序抛出一个异常时，当前正在执行的函数暂时中止，开始查找最邻近的与异常匹配的catch语句。如果查找catch语句的过程中退出了某些函数，函数中定义的局部变量随之销毁</p>
<p>命名空间是一种管理大规模复杂应用程序的机制，这些应用可能是由多个独立的供应商分别编写的代码组合成的。一个命名空间类似于“集合”，是一个作用域，我们在这个大饼内定义对象，类型，函数，模板和其他命名空间（没错，子命名空间）标准库定义在名为std的命名空间中</p>
<p>多重继承的概念非常简单：一个派生类可以从多个直接基类继承而来。多重继承的细节极其复杂，特别是多个基类继承所引入的潜在名字冲突，造成来自基类部分的名字的二义性问题</p>
<h3 id="N10-3-特殊工具与技术"><a href="#N10-3-特殊工具与技术" class="headerlink" title="N10.3-特殊工具与技术"></a>N10.3-特殊工具与技术</h3><p>C++为解决某些特殊问题设置了一系列特殊的处理机制。</p>
<p>有的程序需要精确控制内存分配过程，它们可以通过在类的内部或者全局作用域中自定义operator new和operator delete实现目的。应用程序为这两个操作定义了自己的版本，new和delete表达式将优先使用应用程序定义的版本</p>
<p>有的程序需要运行时直接获取对象的动态形式，运行时类型识别（RTTI）为这种程序提供了语言级别的支持。RTTI只对定义的虚函数的类有效，对于没有定义虚函数的类，虽然能得其类型信息但只是静态类型</p>
<p>C++定义了几种聚集类型<br>嵌套类：在其他类的作用域，块中函数。嵌套类通常作为外层类的实现类<br>union：特殊的类，定义几个数据成员但是在任意时刻只有一个成员有值。通常嵌套在其他类的内部<br>局部类：定义在函数内部，局部类的所有成员都必须定义在类内，局部类不能包含有静态数据成员</p>
<p>C++支持几种固有的不可移植的特性，位域和volatile使得程序更容易访问硬件：链接指示使得程序更容易访问用其他语言编写的代码</p>
<p>判别式是一种使用一个对象判断union的当前值类型的编程技术</p>
<p>枚举——类型和成员，将一组整型常量命名后聚合在一起形成的类型；而枚举成员是常量，可以用在任何需要整型常量的地方</p>
</a>

    </div>

</div>

    </div>

    <!-- 尾部 -->
    <div class="Foot_container">

        <!-- 尾部文字 -->
<div class="Foot_Text">

    <p>
    Copyright©Mish233| 2024 ~ 2025 |Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">hexo</a>
    </p>
    
    <p>
    Using theme <a href="#">Mish233</a> | <span id="Current_Time">Loading</span>
    </p>

</div>


    </div>

    <!-- 后面是JS加载器载入的JS -->

</body>

</html>