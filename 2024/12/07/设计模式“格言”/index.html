<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"> 
<title>Mish233&#39;s Blog</title>
<link rel="icon" type="image/jpg" href="">
<meta name="keywards" content="Mish233,Blog">
<meta name="author" content="Mish233">

<link rel="stylesheet" href="/css/Style.css">


<link rel="stylesheet" href="/css/Index.css">


<link rel="stylesheet" href="/css/Page.css">


<link rel="stylesheet" href="/css/Post.css">


<script src="/js/JSLoader.js"></script>


<script src="/js/Current_Time.js"></script>


<script src="/js/HoverLink.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<body class="Body_container" onload="ScriptLoader()">
    <div class="Top_container">
        <!-- 头部 -->
        <!-- 引入-公共元素-头部区_引导栏 -->
<div class="Top_Navigator">
    <ul>
        <li><a href="/">Home</a></li>
        
            <li><a href="/About/About.html">About</a></li>
        
            <li><a href="/Link/Link.html">Link</a></li>
         
    </ul>
</div>
<!-- 引入-公共元素-头部区_背景 -->
<div class="Top_Background">
    <img src="../../../../img/Top_background.jpg">
</div>
<!-- 引入-公共元素-头部区_背景式标题 -->
<div class="Top_Title">
    <p>Mish233&#39;s Blog</p>
</div>


    </div>

    <div class="Mid_container">
        <!-- 中部 -->
        <!-- 引入-公共元素-左侧栏（头像信息区） -->
<div class="Body_PortraitFramework">
    <!-- 头像 -->
    <div class="Body_Portrait_Img">
    <img src="../../../../img/portrait.jpg">
</div>
    <!-- 图片导航（联系方式）栏 -->
    <div class="Body_Portrait_ImgNavigator">
    
        
            <a target="_blank" rel="noopener" href="https://github.com/Mish233">
            <img src="../../../../img/github.png">
            </a>
        
            <a href="mailto:ffmg2165348339@gmail.com">
            <img src="../../../../img/gmail.png">
            </a>
        
    
</div>
    <!-- 标签分类-文字型 -->
    <div class="Body_Portrait_TagsNavigator">
    <ul class="Body_Portrait_TagsNavigator_list" itemprop="keywords"><li class="Body_Portrait_TagsNavigator_list_li"><a class="Body_Portrait_TagsNavigator_list_a" href="/tags/Git/" rel="tag">Git</a></li><li class="Body_Portrait_TagsNavigator_list_li"><a class="Body_Portrait_TagsNavigator_list_a" href="/tags/%E4%B8%AA%E4%BA%BA%E8%A8%80%E8%AE%BA/" rel="tag">个人言论</a></li><li class="Body_Portrait_TagsNavigator_list_li"><a class="Body_Portrait_TagsNavigator_list_a" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="Body_Portrait_TagsNavigator_list_li"><a class="Body_Portrait_TagsNavigator_list_a" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
</div>

</div>
<!-- 引入-公共元素-主框架（文章区） -->
<!-- 主要的工作量，咕咕咕 -->
<div class="post">
    <!-- 我定义其为文章内容区 -->
    <div class="post_title">
    <!-- 文章_标题 -->
    <h1>设计模式“格言”</h1>
    </div>
    <div class="post_subtitle">
    <!-- 文章_属性（副标题）（补充内容） -->
    <a>2024年12月07日</a>
    </div>
    <div class="post_content">
    <!-- 文章_正文 -->
    <a><p>高质量的代码：基本没有bug，易于理解，适应变革</p>
<p>设计模式（四人帮）只是经典，它并不能完全覆盖掉现实实际任务产生出来的实践最佳模式。</p>
<p>设计模式类似于软件工程里“零件”，当你需要时，想一想哪些设计模式“零件”可以塞进你的工程里面。<br>“零件”的目的正是为了————让你的“工业引擎”尽可能以一种“易维护，高性能”的方式运行。</p>
<p>设计模式是基于现实的，并不仅限于代码工程中使用……倒不如说是现实的各种高效地实践，在代码上以“零件”的方式体现了</p>
<p>所以，也请不要尝试塞一大堆“零件”在你的工程里面，根据需要而尝试塞入一些特效“零件”即可。“零件”过多造成的故障也是惊人的，而且运行效率也不会在实际好到哪去————毕竟你是敲了几行代码上去来实现这个设计模式而实实在在地占用着代码空间</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型设计模式抽象了实例化过程。它们能帮助系统独立地如何创建，组合，表示那些对象。</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>“提供一个接口以创建一系列相关或相互依赖的对象，无需指定它们具体类“</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>”将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示”</p>
<h3 id="工厂模型"><a href="#工厂模型" class="headerlink" title="工厂模型"></a>工厂模型</h3><p>“定义一个用于创建对象的接口，让子类决定实例化哪一个类。将类的实例化转移到子类行为”</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>“用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象”</p>
<p>“好了，我设计好了一台四号原型车。设计师们，请你们在这个原型车的基础上进行改造吧——嗯四号A，四号C，ETC….还不错嘛“</p>
<h3 id="单件"><a href="#单件" class="headerlink" title="单件"></a>单件</h3><p>“保证一个类仅有一个实例，提供一个全局访问点”</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式涉及如何组合类和对象以获得更大的类-类关系结构。结构型的类模式采用继承机制来组合接口和实现</p>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>“将一个类的接口转换成客户希望的另外一个接口。适配器使得一些原本因为接口不兼容而不能一起工作的类一起工作”</p>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p>”将抽象部分和它的实现部分分离，使它们各自可以独立变化”</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>“将对象组合成树形结构以表示部分-整体的层次结构。组合使得用户能更客观的在一个被划分好的区域使用功能类似一致的单个对象或对象组合“</p>
<h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><p>“动态地为一个对象添加一些额外的任务。增加功能而言，装饰相比生成一个子类更灵活”</p>
<h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>”为子系统中的一组接口提供一个一致界面（不如说提供一个类专门放这些接口，相当于是总导航器了）。外观模式定义了一个高层接口，使得这一子系统更加容易使用</p>
<h3 id="享元？（还是叫公共类元吧，这更好听）"><a href="#享元？（还是叫公共类元吧，这更好听）" class="headerlink" title="享元？（还是叫公共类元吧，这更好听）"></a>享元？（还是叫公共类元吧，这更好听）</h3><p>“利用共享技术，聚合成一个”公共类表“，在可观的未来，对象可以直接从”公共类表“提取公共类元而无需在每一个对象一个个生成类元”</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>“为其他对象提供一种代理（控制台）控制对象访问（或者顺序）”</p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式涉及算法和对象间职责的分配。行为型模式不仅描述对象或类的模式，还描述它们之间的通信模式</p>
<h3 id="职责链"><a href="#职责链" class="headerlink" title="职责链"></a>职责链</h3><p>“使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，沿着这条链传递任务的请求，中途的所有对象都可以处理这个任务，或者自己（当前对象）不行，直到最后一个”</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>“将一个请求封装为一个对象，从而使你可将大量请求塞进去，让你的请求参数化地让客户同时进行”</p>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>“给定一组语言（我想这可能是哪个破函数给一个源码加密了），定义它的文法的一种表示（破函数给我的宝贝源码加密了），定义一个解释器来解释这组语言”</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>“提供一种方法顺序访问一个聚合对象（数组）中的各个元素，不需要暴露该对象的内部表示”</p>
<h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><p>“不破坏封装性，捕获对象内部状态，并在该对象之外保存目前状态，以后可以将对象恢复到原先保存的状态”</p>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>“定义外界一个观察者对象，监视管辖内所有对象，其一对象发生更新时传递信息给观察者，观察者同步更新信息给管辖内所有其他未更新的对象（不用一个个跑了，传递到一个枢纽，然后枢纽直接输出更新信息）”</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>”允许一个对象在内部状态改变时改变它的行为（多态？）。如同对象改变了自己的类“</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>“定义一系列算法，一个个封装好，使它们相互调换。算法独立而满足用户需要时直接调用”</p>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>“定义一个操作中算法的骨架，而将一些步骤延迟到子类（父类为骨，子类为分支，行为渐渐延伸到底，渐进式，同时性，动作发生）。模板方法使得子类不改变算法结构即可重新定义该算法的某些步骤（没错没错，父类是算法的整体，现在子类是算法的分治行为，通过修改子类我们可以改变算法，让它成为另一个算法）”</p>
<h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><p>“表示一个作用于某个对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作”</p>
</a>
    </div>
</div>
    </div>
    
    <div class="Foot_container">
        <!-- 尾部 -->
        <!-- 引入-公共元素-尾部声明 -->
<div class="Foot_Text">
    <p>
    Copyright©Mish233| 2024 ~ 2025 |Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">hexo</a>
    </p>
    <p>
    Using theme <a href="#">Mish233</a> | <span id="Current_Time">Loading</span>
    </p>
</div>

    </div>
    <!-- 后面是JS加载器载入的JS -->
</body>
</html>