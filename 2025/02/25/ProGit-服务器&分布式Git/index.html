<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8"> 
<meta name="keywards" content="Mish233,Blog">
<meta name="author" content="Mish233">

<title>
    Mish233&#39;s Blog
</title>

<link rel="icon" type="image/jpg" href="">

<!--  -->

<link rel="stylesheet" href="/css/Style.css">


<link rel="stylesheet" href="/css/Index.css">


<link rel="stylesheet" href="/css/Page.css">


<link rel="stylesheet" href="/css/Post.css">


<script src="/js/JSLoader.js"></script>


<script src="/js/Current_Time.js"></script>


<script src="/js/HoverLink.js"></script>

<!--  -->

<meta name="generator" content="Hexo 7.3.0"></head>

<body class="Body_container" onload="ScriptLoader()">

    <!--
    对hexo内部函数用注释线划分了 
    -->

    <!-- 头部 -->
    <div class="Top_container">

        <!-- 头部_导航栏 -->
<div class="Top_Navigator">
    <!-- 无序列表，列出各页面 -->

    <ul>
        
        <!-- Home -->
        <li><a href="/">Home</a></li>

        <!-- 子页面 -->
        <!--  -->
        
            <li><a href="/About/About.html">About</a></li>
        
            <li><a href="/Link/Link.html">Link</a></li>
        
        <!--  -->
        
    </ul>
</div>

<!-- 头部_背景 -->
<div class="Top_Background">
    <!-- 背景图片 -->

    <img src="../../../../img/Top_background.jpg">

</div>

<!-- 头部_标题 -->
<div class="Top_Title">
    <!-- 头部标题 -->
    <p>Mish233&#39;s Blog</p>
</div>



    </div>

    <!-- 中部 -->
    <div class="Mid_container">

        <!-- 左侧栏_个人区 -->
<div class="Body_PortraitFramework">

    <!-- 头像 -->
    <div class="Body_Portrait_Img">

    <img src="../../../../img/portrait.jpg">

</div>

    <!-- 图像式个人联系栏 -->
    <div class="Body_Portrait_ImgNavigator">

<!--  -->
    
        
            <a target="_blank" rel="noopener" href="https://github.com/Mish233">
            <img src="../../../../img/github.png">
            </a>
        
            <a href="mailto:ffmg2165348339@gmail.com">
            <img src="../../../../img/gmail.png">
            </a>
        
    
<!--  -->

</div>
    
    <!-- 标签导航栏 -->
    <div class="Body_Portrait_TagsNavigator">

    <!--  -->
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
    <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/Git/">
    <a href="/tags/Git/">Git</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E4%B8%AA%E4%BA%BA%E8%A8%80%E8%AE%BA/">
    <a href="/tags/%E4%B8%AA%E4%BA%BA%E8%A8%80%E8%AE%BA/">个人言论</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </div>
    
    <!--  -->

</div>


</div>

<!-- 右侧栏_文章区 -->
<div class="post">
    <!-- 我定义其为文章内容区 -->

    <!-- 文章_标题 -->
    <div class="post_title">

        <h1>ProGit-服务器&amp;分布式Git</h1>

    </div>

    <!-- 文章_属性（副标题）（补充内容） -->
    <div class="post_subtitle">

        <a>2025年02月25日</a>

    </div>
    
    <!-- 文章_正文 -->
    <div class="post_content">
        
    <a><h2 id="服务器上的Git"><a href="#服务器上的Git" class="headerlink" title="服务器上的Git"></a>服务器上的Git</h2><p>到目前为止，你应该已经有办法使用Git来完成日常工作。为了使用Git的协作功能，你还需要有远程的Git仓库——与他人合作的最佳方法即是建立一个你与合作者们都有权限访问，且可从那里推送和拉取资料的共用仓库</p>
<p>一个远程仓库通常只是一个裸仓库——即一个没有当前工作目录的仓库。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Git可以使用四种不同的协议来传输资料：本地协议，Http协议，SSH协议及Git协议</p>
<h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的是本地协议，其中的远程版本库就是同一主机上的另一个目录。常见于团队的每一个成员都对一个共享的文件管理系统拥有访问权，或者比较少见的多人共用一台电脑的情况</p>
<p>如果你使用共享文件系统，就可以从本地版本库进行<code>clone</code>，<code>push</code>，<code>pull</code>。下面是如何进行<code>clone</code>的操作：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> .../.././&lt;GitName&gt;.git</span></span><br></pre></td></tr></table></figure>

<p>要增加一个本地版本库到现有的Git项目，可以进行这样的指令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add &lt;RemoteProject&gt; .../.././&lt;GitName&gt;.git</span></span><br></pre></td></tr></table></figure>
<p>这样，就可以通过新的远程仓库，像在网络上一样从远端版本库推送和拉取更新了</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>非常简单，直接利用现有文件权限和网络访问权限。这也是快速从别人工作目录中拉取更新的方法</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>共享文件系统比较难配置，相比起基本网络连接访问，共享文件系统局限性很大，不方便多电脑的访问。这个协议并不保护仓库避免意外的损坏</p>
<h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h4><p>Git通过Http通信有两种模式：智能Http协议（新）和哑Http协议（旧）</p>
<h5 id="智能Http协议"><a href="#智能Http协议" class="headerlink" title="智能Http协议"></a>智能Http协议</h5><p>智能Http的运行方式和SSH及Git协议类似，只是运行在标准的Http&#x2F;S端口上并且使用各种Http验证机制，比如使用Http协议的用户名&#x2F;密码验证</p>
<p>智能Http的运行方式或许已经是最流行的使用Git的方式了，它既支持<code>git://</code>协议一样设置匿名服务，也可以像SSH协议一样提供传输时的授权和加密。而且只用一个URL都可以做到</p>
<h5 id="哑（Dumb）Http协议"><a href="#哑（Dumb）Http协议" class="headerlink" title="哑（Dumb）Http协议"></a>哑（Dumb）Http协议</h5><p>如果服务器不支持智能Http协议，Git客户端会尝试使用更简单的哑Http协议。哑Http协议里的Web服务器仅仅把裸版本库当作普通文件来对待，提供文件服务。设置非常简单——只需要把一个裸版本库放在Http根目录，设置一个<code>post-update</code>的挂钩就可以了。下面是流程：<br>切换到Apache里的<code>~/var/www/htdocs</code>位置（例子，实际你只需要把裸版本库放在正确的目录就可以）<br>创建一个Git仓库<br>位置切换进Git仓库目录<br>输入下面的指令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hooks/post-update.sample hooks/post-update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> a+x hooks/post-update</span></span><br></pre></td></tr></table></figure>

<p>这样就可以了。Git自带的<code>post-update</code>挂钩会默认执行合适的指令以确保Http的获取和克隆工作。使用下面的指令来进行克隆：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://.../&lt;GitName&gt;.git</span></span><br></pre></td></tr></table></figure>

<p>通常的，在提供读&#x2F;写的智能Http服务和简单的只读哑Http服务之间我们往往只会选择一个，极少将二者混合使用</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>仅关注智能Http协议的优点</p>
<p>不同的访问方式只需要一个URL以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用Git变得非常简单——可以使用用户名&#x2F;密码授权将是一个很大的优势，这样用户就不必在使用Git之前先在本地生成SSH密钥对再把公钥上传到服务器</p>
<p>你也可以在Https协议上提供只读版本库的服务</p>
<p>另一个好处是Https被广泛使用，一般的企业防火墙会允许这些端口的数据通过</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>在一些服务器上，假设Https协议的服务端会比SSH协议的棘手一点</p>
<p>如果你在Http上使用需授权的推送，管理凭证会比使用SSH密钥认证麻烦一点（存储问题）</p>
<p>用户体验上，你每一次使用都需要输入一长串密码&#x2F;用户名，非常不自动化</p>
<h4 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h4><p>架设Git服务器时常用SSH协议作为传输协议。大多数环境下服务器已经支持通过SSH访问——即使没有很容易架设。SSH协议也是一个验证授权的网络协议</p>
<p>通过SSH协议克隆版本库，你可以指定一个<code>ssh://</code>的URL：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> ssh://[user@]server/&lt;GitName&gt;.git</span></span><br></pre></td></tr></table></figure>
<p>或者这样简写：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> [user@]server/&lt;GitName&gt;.git</span></span><br></pre></td></tr></table></figure>
<p>如果你不指定可选的用户名，那么Git会使用当前登录的用户名字</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>SSH的架设简单，多数操作系统有成熟的相关管理工具；SSH访问十分安全——所有传输数据需要授权和加密；SSH会尽量压缩传输数据，追求高效</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>不支持匿名访问，如果你要同时提供匿名访问服务，你还得架设一个其他人能够访问的服务</p>
<h4 id="Git协议"><a href="#Git协议" class="headerlink" title="Git协议"></a>Git协议</h4><p>这是包含在Git里的一个特殊守护进程；它监听一个特定的端口（9418），类似于SSH服务，但是无需访问授权。要让版本库支持Git协议，需要先创建一个<code>git-deamon-export-ok</code>文件。但是没有任何安全措施，要么谁都能克隆这个版本库要么谁都不能</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>相比起其他所有访问协议是最快的</p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>缺乏授权机制（所有人都能读写）；最难架设的：守护进程+配置程序+9418非标准端口（大型服务器默认封闭）</p>
<h3 id="在服务器上搭建Git"><a href="#在服务器上搭建Git" class="headerlink" title="在服务器上搭建Git"></a>在服务器上搭建Git</h3><p>在开始架设Git服务器前，需要把现有仓库导出为裸仓库——不包含当前工作目录的仓库。为了通过克隆你的仓库来创建一个新的裸仓库，你需要在<code>clone</code>之后使用参数<code>--bare</code>。操作如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --bare &lt;GitName&gt; &lt;GitName&gt;.git</span></span><br></pre></td></tr></table></figure>

<p>接着你需要把这个裸仓库放在服务器上并且设置好你的协议。假设你已经有了域名以及相关架构的服务器，并可以通过SSH进行连接。你可以通过以下操作复制你的裸仓库来创建一个新仓库：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scp -r &lt;GitName&gt;.git &lt;user@&lt;Example.Com&gt;&gt;:&lt;.../../.&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时其他可通过SSH读取此服务器上<code>&lt;.../../.&gt;</code>的用户，可以运行下面的指令来克隆你的仓库</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> &lt;user@&lt;Example.Com&gt;&gt;:/.../.././&lt;GitName&gt;.git</span></span><br></pre></td></tr></table></figure>
<p>如果一个用户，通过使用SSH连接一个服务器，并且其对工作目录（服务器的）拥有可写权限，那么他将自动拥有推送权限</p>
<p>值得注意的是，这的确是架设一个几个人拥有连接权的Git服务的全部——只要在服务器上加入可以用SSH登录的账号，然后把裸仓库放在大家都有读写权限的地方</p>
<h3 id="生成SSH公钥"><a href="#生成SSH公钥" class="headerlink" title="生成SSH公钥"></a>生成SSH公钥</h3><p>如前所述，许多Git服务器都使用SSH公钥进行认证。为了向Git服务器提供SSH公钥，如果某系统的用户没有生成自己的SSH公钥，必须事先为其生成一份。默认情况下，用户的密钥存储在<code>~/.ssh</code>目录下</p>
<p>我们需要寻找一对以<code>id_dsa</code>或<code>id_rsa</code>命名的文件，其中一个带有<code>.pub</code>扩展名。那个<code>.pub</code>格式的文件是你的公钥，而另一个则是你的私钥。如果找不到这样的文件（或者你连<code>.ssh</code>文件夹都没看到），你可以通过运行<code>ssh-keygen</code>来创建它们。在Linux&#x2F;MacOS中，<code>ssh-keygen</code>随SSH软件包提供；而对于Window，程序包含在MSysGit软件包中。指令输入如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -o</span></span><br></pre></td></tr></table></figure>
<p>首先<code>ssh-keygen</code>指令会确认密钥的存储位置，然后要求你输入两次密钥口令（不想输入就留空）。如果你使用了密码，确保添加了<code>-o</code>参数，它会以比默认格式更能抗暴力破解的格式保存私钥</p>
<p>经过上述流程创建密钥（或者说你已经有了），我们可以把各自的密钥发送给任意一个Git服务器管理员，也就是复制你们各自的<code>.pub</code>格式文件，并且私发给对方（切忌，私密性）</p>
<p>公钥看上去类似这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@mylaptop.local</span><br></pre></td></tr></table></figure>

<h3 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>让我们来看看如何配置服务端的SSH访问。假设：Linux</p>
<p>首先，创建操作系统用户<code>git</code>（将Git安装到你的OS里面），为其创建一个<code>.ssh</code>目录</p>
<p>接着我们需要为系统用户<code>git</code>的<code>authorized_keys</code>文件添加一些开发者SSH公钥。假设我们有了这些（其他用户的）公钥，我们要将这些公钥加入系统用户<code>git</code>的<code>.ssh</code>文件夹里的<code>authorized_keys</code>文件的末尾</p>
<p>之后，创建一个远程裸仓库，其他的（加了密钥）开发者则能开始将自己的工作流（分支）推送到你的目的远程服务器</p>
<p>经过上述操作，我们很容易地快速搭建了一个具有读写权限，面向多个开发者的Git服务器</p>
<p>如果你想对加入的开发者做点权限限制（只能Pull&#x2F;Push），你可能需要借助<code>git-shell</code>的受限shell工具</p>
<p>首先你要确保<code>git-shell</code>的完整路径名已存在于<code>/etc/shells</code>文件中</p>
<p>现在你可以使用如下操作，对任一系统用户shell进行修改：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> chsh git -s $(<span class="built_in">which</span> git-shell)</span></span><br></pre></td></tr></table></figure>

<h3 id="Git守护进程"><a href="#Git守护进程" class="headerlink" title="Git守护进程"></a>Git守护进程</h3><p>Git协议建立一个基于守护进程的仓库。对于快速且无需授权的Git数据访问，这是一个理想之选</p>
<p>Git协议都是相对容易设置的。操作如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git deamon --reuseddr --base-path=&lt;/../.&gt; &lt;../.&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>--reuseddr</code>选项允许服务器在无需等待旧连接超时的情况下重启；<code>base-path</code>选项允许用户在用户未完成指定路径条件下克隆项目，结尾的路径将告诉Git守护进程从何处寻找仓库来导出。如果防火墙仍然运行，确保开放9418端口的通信权限</p>
<h3 id="Smart-Http"><a href="#Smart-Http" class="headerlink" title="Smart Http"></a>Smart Http</h3><p>我们一般通过SSH进行授权访问，通过git:&#x2F;&#x2F;进行无授权访问，但是还有一种协议可以同时实现两种以上的访问。设置SmartHttp一般只需要在服务器上启用一个Git自带的名为<code>git-http-backend</code>的CGI脚本。该CGI脚本将会读取由<code>git fetch</code>和<code>git push</code>命令向Http URL发送的请求路径和头部信息，来判断该客户端是否支持Http通信</p>
<p>我们将使用Apache来作为CGI服务器。如果你没有安装Apache，你可以在Linux环境下执行如下或类似的指令来安装：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install apache2 apache2-utils</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">a2enmod cgi <span class="built_in">alias</span> <span class="built_in">env</span></span></span><br></pre></td></tr></table></figure>
<p>该操作会启用<code>mod_cgi</code>，<code>mod_alias</code>和<code>mod_env</code>等Apache模块，这些模块都是使该功能正常工作所必需的</p>
<p>你还需要将<code>/srv/git</code>的Unix用户组设置为<code>www-data</code>，这样Web服务器才能读写该仓库，因为运行CGI脚本的Apache实例默认以该用户的权限运行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">charp -R www-data /srv/git</span></span><br></pre></td></tr></table></figure>

<p>接下来我们要向Apache配置文件添加一些内容，来让<code>git-http-backend</code>作为Web服务器对<code>/git</code>路径请求的处理器</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SetEnv GIT_PROJECT_ROOT /srv/git</span><br><span class="line">SetEnv GIT_HTTP_EXPORT_ALL</span><br><span class="line">ScriptAlias /git/ /usr/lib/git-core/git-http-backend/</span><br></pre></td></tr></table></figure>
<p>如果留空<code>GIT_HTTP_EXPORT_ALL</code>这个环境变量，Git将只对无授权客户提供带<code>git-deamon-export-ok</code>文件的版本库，就像Git守护进程一样</p>
<p>最后，如果想让Apache允许<code>git-http-backend</code>请求并实现写入操作的授权验证，使用如下授权屏蔽配置：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Files &quot;git-http-backend&quot;&gt;</span><br><span class="line">    AuthType Basic</span><br><span class="line">    AuthName &quot;Git Access&quot;</span><br><span class="line">    AuthUserFile /srv/git/.htpasswd</span><br><span class="line">    Require expr !(%&#123;QUERY_STRING&#125; -strmatch &#x27;*service=git-receive-pack*&#x27; || %&#123;REQUEST_URI&#125; =~ m#/git-receive-pack$#)</span><br><span class="line">    Require valid-user</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure>

<p>这需要你创建一个包含所有合法用户密码的<code>.httpasswd</code>文件。以下是一个添加“schacon“用户到此文件的例子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">htpasswd -c /srv/git.htpasswd schacon</span></span><br></pre></td></tr></table></figure>
<p>你可以通过许多方式添加Apache授权用户，选择其中一种方式即可</p>
<h2 id="分布式Git"><a href="#分布式Git" class="headerlink" title="分布式Git"></a>分布式Git</h2><p>你现在有了一个远程Git版本库，能为所有开发者共享代码提供服务了，在本地工作流程下，你也已经熟悉了基本Git指令。让我们开始分布式的工作开发吧</p>
<h3 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h3><p>与传统的集中式版本控制系统（CVCS）相反，Git的分布式特性使得开发者间的协作变得更加灵活多样。在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。而在Git中，每个开发者同时扮演着节点和集线器的角色——也就是说，每个开发者既可以将自己的代码贡献到其他仓库中，同时也维护自己的公开仓库，让其他人可以在其基础上工作并贡献代码（毕竟服务器&#x3D;电脑&#x3D;冯诺伊曼体系计算机嘛）。我们接下来介绍一些比较常见的工作流开发实现模型</p>
<h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h4><p>集中式系统中通常使用的是单点协作模型——也就是设置一台“共享区“，所有开发者使用电脑访问共享区仓库一起修改开发一个工程，多个开发者作为“共享区”的多个远程分支进行工作</p>
<h4 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h4><p>Git允许多个远程仓库存在，使得这样一种工作流存在：每个开发者有自己仓库的写权限和其他所有人的读权限。存在官方仓库，其他只有读权限的开发者获取官方仓库，然后在自己的仓库用写权限自行开发（某种功能），然后将自己的仓库推送上去，并且请求官方下一次将自己的仓库更新合并到主项目（实现互助式更新）</p>
<h4 id="主管-副主管工作流"><a href="#主管-副主管工作流" class="headerlink" title="主管&#x2F;副主管工作流"></a>主管&#x2F;副主管工作流</h4><p>多仓库工作流的变种</p>
<p>我们假设一个主管，更新自己的“面向所有开发者”的公开仓库</p>
<p>开发者们获得这个大公开仓库，拉到自己的仓库，自己开发相应模块</p>
<p>副主管对应某个主题，管理某个主题小组，那些开发者们将自己开发的东西提交给副主管，副主管对应的“子主题分支”持续进行中</p>
<p>最后，副主管在合适时机，联系主管更新工程，并且推动公开仓库的更新</p>
<p>值得一提的是，这是可以无限扩展的“层状”结构，不过我们更推荐项目大到一定程度才使用这种工作流（太扯皮了）</p>
<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul>
<li>ProGit中文版——<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></li>
</ul>
</a>

    </div>

</div>

    </div>

    <!-- 尾部 -->
    <div class="Foot_container">

        <!-- 尾部文字 -->
<div class="Foot_Text">

    <p>
    Copyright©Mish233| 2024 ~ 2025 |Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">hexo</a>
    </p>
    
    <p>
    Using theme <a href="#">Mish233</a> | <span id="Current_Time">Loading</span>
    </p>

</div>


    </div>

    <!-- 后面是JS加载器载入的JS -->

</body>

</html>