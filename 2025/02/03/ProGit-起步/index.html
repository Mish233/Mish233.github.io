<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8"> 
<meta name="keywards" content="Mish233,Blog">
<meta name="author" content="Mish233">

<title>
    Mish233&#39;s Blog
</title>

<link rel="icon" type="image/jpg" href="">

<!--  -->

<link rel="stylesheet" href="/css/Style.css">


<link rel="stylesheet" href="/css/Index.css">


<link rel="stylesheet" href="/css/Page.css">


<link rel="stylesheet" href="/css/Post.css">


<script src="/js/JSLoader.js"></script>


<script src="/js/Current_Time.js"></script>


<script src="/js/HoverLink.js"></script>

<!--  -->

<meta name="generator" content="Hexo 7.3.0"></head>

<body class="Body_container" onload="ScriptLoader()">

    <!--
    对hexo内部函数用注释线划分了 
    -->

    <!-- 头部 -->
    <div class="Top_container">

        <!-- 头部_导航栏 -->
<div class="Top_Navigator">
    <!-- 无序列表，列出各页面 -->

    <ul>
        
        <!-- Home -->
        <li><a href="/">Home</a></li>

        <!-- 子页面 -->
        <!--  -->
        
            <li><a href="/Link/Link.html">Link</a></li>
        
            <li><a href="/About/About.html">About</a></li>
        
        <!--  -->
        
    </ul>
</div>

<!-- 头部_背景 -->
<div class="Top_Background">
    <!-- 背景图片 -->

    <img src="../../../../img/Top_background.jpg">

</div>

<!-- 头部_标题 -->
<div class="Top_Title">
    <!-- 头部标题 -->
    <p>Mish233&#39;s Blog</p>
</div>



    </div>

    <!-- 中部 -->
    <div class="Mid_container">

        <!-- 左侧栏_个人区 -->
<div class="Body_PortraitFramework">

    <!-- 头像 -->
    <div class="Body_Portrait_Img">

    <img src="../../../../img/portrait.jpg">

</div>

    <!-- 图像式个人联系栏 -->
    <div class="Body_Portrait_ImgNavigator">

<!--  -->
    
        
            <a target="_blank" rel="noopener" href="https://github.com/Mish233">
            <img src="../../../../img/github.png">
            </a>
        
            <a href="mailto:ffmg2165348339@gmail.com">
            <img src="../../../../img/gmail.png">
            </a>
        
    
<!--  -->

</div>
    
    <!-- 标签导航栏 -->
    <div class="Body_Portrait_TagsNavigator">

    <!--  -->
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/Git/">
    <a href="/tags/Git/">Git</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
    <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E4%B8%AA%E4%BA%BA%E8%A8%80%E8%AE%BA/">
    <a href="/tags/%E4%B8%AA%E4%BA%BA%E8%A8%80%E8%AE%BA/">个人言论</a>
    </div>
    
    <div class="Body_Portrait_TagsNavigator_list" onclick="HoverLink(this)" url="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </div>
    
    <!--  -->

</div>


</div>

<!-- 右侧栏_文章区 -->
<div class="post">
    <!-- 我定义其为文章内容区 -->

    <!-- 文章_标题 -->
    <div class="post_title">

        <h1>ProGit-起步</h1>

    </div>

    <!-- 文章_属性（副标题）（补充内容） -->
    <div class="post_subtitle">

        <a>2025年02月03日</a>

    </div>
    
    <!-- 文章_正文 -->
    <div class="post_content">
        
    <a><h1 id="ProGit"><a href="#ProGit" class="headerlink" title="ProGit"></a>ProGit</h1><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>Git入门</p>
<h3 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h3><p>版本控制是一种记录一个或若干个内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p>假设一条时间线吧，我们的版本记录尝试记录以前所存在的版本副本，然后更新时允许我们快速获得（备份好的文件）副本。假设有些时候吧，你的更新被证实是无用的时候，我们可以快速回滚到旧版本重新进行开发</p>
<h4 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h4><p>人们很久以前就开发了许多种本地版本控制，大多数都是采用某种简单的数据库来记录文件的历次更新差异</p>
<p>其中一种最流行的叫做RCS，现今许多计算机系统都还能看到它的踪影。RCS的工作原理就是保存补丁集（补丁指文件更新前后的变更的内容）；然后我们定义元版本（最开始的版本），然后给补丁进行线性编号，最后我们无限堆叠“打补丁”，我们可以简单的统计出目前文件的版本号是多少了，如果我需要旧版，就打多少个“补丁”上去（然后如果我们需要最新版，则把所有补丁打上去就行了）</p>
<h4 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h4><p>如何让不同系统上的开发者协同工作？这时我们需要一个集中化的版本控制系统（CVCS）。CVCS都有一个单一集中管理的服务器，保存所有文件的修订版本，协同工作者连接这个服务器获取“共同开发产品”。简单来讲就是——提供一个“允许多人访问”的共享服务器，所有人只需要获取元版本，然后开发成新版本，共同放到这个共享区，并交给下一个人进行开发</p>
<p>现在所有人都知道项目的其他人的分工了，也允许我们多人尝试进行开发了</p>
<p>小心服务器的故障，因为我们假设的共享区是一个“单点服务器”，一旦这个单一服务器产生故障，人们将无法对文件进行任何操作，并且丢失所有“版本记录“</p>
<h4 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h4><p>于是分布式版本控制（DVCS）面世了——我们的电脑为什么不能负责“版本记录”工作呢？我们尝试给服务器下发下来的开发产品引入“框架“（代码仓库)，这个框架允许我们对当前的版本进行分布备份，并在假设的共享区崩溃时，允许我们本地电脑的版本记录成为恢复共享区的依据。</p>
<p>更进一步，我们也不需要假设共享区必须是一个稳定存在的服务器了，这将允许我们两台电脑相互转化为——开发者与共享区的相对存在</p>
<p>不过DVCS的缺点就是，版本的“局部性”，如果旧版根本没人下载，那么可想而知的就是没有人为旧版备份。但这个缺点也并非就是坏事，因为不是所有的程序员都是“考古学家”</p>
<h3 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h3><h4 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h4><p>大部分系统以文件变更列表的方式存储信息，这类系统将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异（基于差异）</p>
<p>但是很多时候，我们需要对每一次差异比较而专门让它独立作为一个“版本文件”存在？不，我们Git为此对待这种部分变更，采用了快照流这种思考。假设我们存储多个文件，更新的部分文件则会在这个版本覆盖掉过去的版本；而另一部分未更新的文件，在当前版本则设置一个指向旧版本文件的链接（表示这个版本你还是用旧版玩意）（如果这个文件一直不更新，那么你的所有新版都指向元文件链接）。这对于内存紧张的服务器来说，它的确减少了多余的堆积同版本文件</p>
<h4 id="几乎所有操作都是本地执行"><a href="#几乎所有操作都是本地执行" class="headerlink" title="几乎所有操作都是本地执行"></a>几乎所有操作都是本地执行</h4><p>我们上文显然提到了开发者和共享区的两个存在——Git的思想基于开发者和共享区两个存在的相对定位。我们不需要一个单独的第三方服务器来作为中间区域交换文件，往往我们只需要在开发者和共享区两大角色间相互转换，便能实现两台电脑的本地传输</p>
<p>在这种情况下，我们的所有Git掌控下的文件几乎都保存了所有的”快照流“。你相当于在本地访问数据仓库（而不是经过互联网连接第三方服务器进行访问），我们不需要经过不靠谱，且耗时的网络了。并且允许你在人类文明衰落时候（至少是互联网消失的时候），允许你直接在你唯一的“黄金文明”产物——电脑，来直接访问唯一的新版（乐）</p>
<h4 id="Git保证完整性"><a href="#Git保证完整性" class="headerlink" title="Git保证完整性"></a>Git保证完整性</h4><p>Git中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。校验和采用SHA-1哈希（散列，Hash），由40个十六进制组成的字符串，基于Git中文件的内容或目录结构计算出来。实际上，Git数据库中存储的信息是以文件内容的哈希值来索引，而不是文件名</p>
<h4 id="Git一般只添加数据"><a href="#Git一般只添加数据" class="headerlink" title="Git一般只添加数据"></a>Git一般只添加数据</h4><p>基于上述的快照流讨论，我们一般几乎是只往Git数据库添加数据，而不是删除数据。也就是说Git几乎不会执行任何可能导致文件不可恢复的操作</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>如果你想在 Linux 上用二进制安装程序来安装基本的 Git 工具，可以使用发行版包含的基础软件包管理工具来安装。 以 Fedora 为例，如果你在使用它（或与之紧密相关的基于 RPM 的发行版，如 RHEL 或 CentOS），你可以使用 <code>dnf</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install git-all</span></span><br></pre></td></tr></table></figure>

<p>如果你在基于 Debian 的发行版上，如 Ubuntu，请使用 <code>apt</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install git-all</span></span><br></pre></td></tr></table></figure>

<p>要了解更多选择，Git 官方网站上有在各种 Unix 发行版的系统上安装步骤，网址为 <a target="_blank" rel="noopener" href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a>。</p>
<h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><p>在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 Xcode Command Line Tools。 Mavericks （10.9） 或更高版本的系统中，在 Terminal 里尝试首次运行 ‘git’ 命令即可。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git --version</span></span><br></pre></td></tr></table></figure>

<p>如果没有安装过命令行开发者工具，将会提示你安装。</p>
<h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><p>在 Windows 上安装 Git 也有几种安装方法。 官方版本可以在 Git 官方网站下载。 打开 <a target="_blank" rel="noopener" href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>，下载会自动开始。 要注意这是一个名为 Git for Windows 的项目（也叫做 msysGit），和 Git 是分别独立的项目；更多信息请访问 <a target="_blank" rel="noopener" href="http://msysgit.github.io/">http://msysgit.github.io/</a>。</p>
<p>要进行自动安装，你可以使用 <a target="_blank" rel="noopener" href="https://chocolatey.org/packages/git">Git Chocolatey 包</a>。 注意 Chocolatey 包是由社区维护的。</p>
<p>另一个简单的方法是安装 GitHub Desktop。 该安装程序包含图形化和命令行版本的 Git。 它也能支持 Powershell，提供了稳定的凭证缓存和健全的换行设置。 稍后我们会对这方面有更多了解，现在只要一句话就够了，这些都是你所需要的。 你可以在 GitHub for Windows 网站下载，网址为 <a target="_blank" rel="noopener" href="https://desktop.github.com/">GitHub Desktop 网站</a>。</p>
<h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p>Git自带一个<code>git config</code>的工具来帮助设置控制Git外观和行为的参数变量。这些变量存储在三个不同位置：</p>
<ol>
<li><p><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</p>
</li>
<li><p><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</p>
</li>
<li><p>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</p>
</li>
</ol>
<p>每一个级别会覆盖上一级别的配置</p>
<p>你可以通过以下命令查看所有的配置以及它们所在的文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list --show-origin</span></span><br></pre></td></tr></table></figure>

<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>安装完Git之后，要做的第一件事就是设置你的用户名和邮件地址。每一次Git提交都会使用这些信息，它们会写入你的每一次提交</p>
<p>下面是例子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email johndoe@example.com</span></span><br></pre></td></tr></table></figure>

<h4 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h4><p>用户信息设置完毕之后你可以配置默认文本编辑器了，当Git需要你输入信息时会调用它。如果未配置，Git会使用OS默认的文本编辑器</p>
<p>如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.editor emacs</span></span><br></pre></td></tr></table></figure>

<p>在 Windows 系统上，如果你想要使用别的文本编辑器，那么必须指定可执行文件的完整路径。 它可能随你的编辑器的打包方式而不同。</p>
<h4 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h4><p>如果想检查你的配置，可以使用<code>git config --list</code>命令来列出所有Git当时能找到的配置</p>
<p>你可以通过输入 <code>git config &lt;key&gt;</code> 来检查 Git 的某一项配置</p>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>想要获取帮助请使用：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">help</span> &lt;verb&gt;</span></span><br></pre></td></tr></table></figure>
<p>（这里我没列出其他的形式，一个就够了。如果有哪些”砖家“喜欢在这里大做文章，考查多少形式（以及那些形式怎么表达），无意义地把问题复杂化，他们往往“脑子不够聪明”，是一群“大聪明”）</p>
<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul>
<li>Progit中文版——<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></li>
</ul>
</a>

    </div>

</div>

    </div>

    <!-- 尾部 -->
    <div class="Foot_container">

        <!-- 尾部文字 -->
<div class="Foot_Text">

    <p>
    Copyright©Mish233| 2024 ~ 2025 |Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">hexo</a>
    </p>
    
    <p>
    Using theme <a href="#">Mish233</a> | <span id="Current_Time">Loading</span>
    </p>

</div>


    </div>

    <!-- 后面是JS加载器载入的JS -->

</body>

</html>